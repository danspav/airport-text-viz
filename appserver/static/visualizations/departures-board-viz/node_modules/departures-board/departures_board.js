class departures_board{
	constructor(){
		this.words = [];
		this.value = ""; // The value for token_id
		this.id = this.createUUID();
		this.caption = ""
		this.label="";
		this.max_num_characters = 50;	// Defined here - limit the num_chars of the viz
		//Defaults:
		this.num_characters = 5;
		this.auto_refresh = true;
		this.auto_refresh_period = 5;
		this.timing = 500;
		this.size = "XXL";
		this.dark_tiles = false;
		this.force_all_caps = true;
		this.token_word = "dbv_term";
		this.token_id = "dbv_id";
		this.is_fixed_length = false;
		this.align = "left";
		this.text_align="left"
		this.mvc = "";
		this.interval_handler = "";
		this.colors = [];
		this.customColor;
	}
	
	
	
	setConfig(config, namespace, mvc){
		// Get Config parameters:
			var vizUtils = require('api/SplunkVisualizationUtils');
		
			this.num_characters = parseInt(config[namespace + 'num_characters']) || 5;
			if (this.num_characters > this.max_num_characters) { this.num_characters = this.max_num_characters;}
			this.auto_refresh = vizUtils.normalizeBoolean(config[namespace + "auto_refresh"], true);
			this.auto_refresh_period = parseInt(config[namespace + 'auto_refresh_period']) || 5;
			this.timing = parseInt(config[namespace + 'timing']) || 500;
			this.size = vizUtils.escapeHtml(config[namespace + 'size']) || "XXL";;
			this.theme = vizUtils.escapeHtml(config[namespace + "theme"]) || "light";
			this.force_all_caps = vizUtils.normalizeBoolean(config[namespace + "force_all_caps"], true);
			this.label = vizUtils.escapeHtml(config[namespace + "label"]) || "";
			this.customColor = vizUtils.escapeHtml(config[namespace + "customColor"]) || "#ffffff";
			
			this.token_word = vizUtils.escapeHtml(config[namespace + "token_term"]) || "dbv_term";
			this.token_id = vizUtils.escapeHtml(config[namespace + "token_id"]) || "dbv_id";
			this.caption="";
			this.is_fixed_length = vizUtils.normalizeBoolean(config[namespace + "is_fixed_length"],false);
			this.align = vizUtils.escapeHtml(config[namespace + "align"]) || "left";
			this.text_align = vizUtils.escapeHtml(config[namespace + "text_align"]) || "left";
			
			this.force_all_caps = (this.force_all_caps=="true");
			this.theme = (this.theme=="light") ? "light" : "dark";
			this.auto_refresh = (this.auto_refresh=="true");
			this.is_animated = (this.is_animated=="true");
			this.is_fixed_length = (this.is_fixed_length=="true");
			if(!this.is_fixed_length){
				this.num_characters = 1;
			}
			this.timing = parseInt(this.timing,10);
			if(this.timing<1) { this.timing = 1;}
			
			this.mvc = mvc
			
			// Clean caption
			var vizUtils = require('api/SplunkVisualizationUtils');
			this.label = vizUtils.escapeHtml(this.label)
			
			
			//Refresh period cannot be less than 1s
			var reValidateRefreshPeriod = new RegExp("\\d{1,3}(\\.\\d+)?");
			if( reValidateRefreshPeriod.test(this.auto_refresh_period)!=true || this.auto_refresh_period <1){ this.auto_refresh_period = 5;}
			
			//Timing mus be at least 100ms
			var reValidateAnimationPeriod = new RegExp("\\d{3,4}");
			if( reValidateAnimationPeriod.test(this.timing)!=true || this.timing <100){ this.timing = 500;}
			
			//Set theme color:
			if(this.theme=="custom"){
				this.addColorDefiniton(this.customColor);
			}
	}
	
	
	
	
	setText(data){
			var SplunkVisUtils = require('api/SplunkVisualizationUtils');
			var vizUtils = require('api/SplunkVisualizationUtils');
			this.caption = ""
			var i = 0;
			var str = "";
			var val = "";
			try{
				//------------------------------  Get data row field indexes ----------------------------------------------------------------------
				
				for(i=0;i<data.rows.length;i++){
					// Set the key value pair:
					str = (this.force_all_caps) ? data.rows[i][0].toUpperCase() : data.rows[i][0];
					val = (data.rows[i].length>1) ? data.rows[i][1] : ""
					this.words.push ({word:str, value: val});
					if(!this.is_fixed_length && str.length > this.num_characters){ 
						//Limit the length to this.max_num_characters
						if (str.length <= this.max_num_characters){ 
							this.num_characters = str.length;
						}else{
							this.num_characters = this.max_num_characters;
						}
					}
				}// loop
				
			} catch(err) {
				console.log("Error setting data. " + err);
			}
		}
	
	// Return the HTML for the visualization
	getHTML(){
		var cssTheme;
		switch(this.theme){
			case "dark":
			cssTheme = "dark";
			break;
			
			case "custom":
			cssTheme = "dark";
			break;
			
			default:
			cssTheme = "light";

		}
		var cssAlign= "text-align: " + this.align + ";";
		if (this.align=="left"){
			cssAlign += "display: inline-block;"
		}
		var html = "<style>" + this.getCSSForCustomColors() + "</style><div class=\"dbv_container\" style=\"" + cssAlign +  "\"><div class=\"dvb_sub_container\"><input class=\"header " + cssTheme + " " + this.size +"\" id=\"" + this.id + "\" /><div class=\"dbv_label\">" + this.label + "</div></div></div>";
		return html;
	}
	
	
	// Get the next word. If we are centre aligning, pad with the right number of spaces.
	getNextWord(){
		try{
			var vals = this.words.shift();
			this.words.push(vals);
			this.caption = vals["word"];
			this.value = vals["value"];
			if(this.text_align=="center"){
				var paddingCount=Math.floor((this.num_characters - vals["word"].length)/2)
				if(paddingCount>0) {
					var padding = Array(paddingCount +1).join(" ")
					vals["word"] = padding + vals["word"]
				}
			}
			return vals['word'];
			
		} catch(err) {
			console.log("Error getting current word" + err);
			return "error!"
		}
	}
	
	
	// Get the OPTS for the visualization
	getOpts(){
		//Center align is just left with padding
		var align = this.text_align;
		if (align=="center") {align="left";}
		return {chars_preset: 'alphanum',
				align: align,
				width: this.num_characters,
				timing: this.timing
				,transform: true
			};
	}
	
	// Create a unique ID for the CSS selector
	createUUID() {
		var s = [];
		var hexDigits = "0123456789abcdef";
		for (var i = 0; i < 10; i++) {
			s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
		}
		var uuid = s.join("");
		return "db_" + uuid;
	}
	
	
		
		start(){
			window.jQuery("#" + this.id).flapper(this.getOpts());
			$("#" + this.id).val(this.getNextWord()).change();
			this.setTokens();
			var thisObj = this;	
					
			if(this.auto_refresh){
				thisObj.interval_handler = window.setInterval(function(){
					//Apoptosis:
					if($("#" + thisObj.id).length==0){
						window.clearInterval(thisObj.interval_handler);
					}else{
						if(thisObj.words.length == 1) {
							$("#" + thisObj.id).val('').change();	
						}
						$("#" + thisObj.id).val(thisObj.getNextWord()).change();
						thisObj.setTokens();
					}
				}, this.auto_refresh_period * 1000);
			}
			
			
		}
	
	
		setTokens(){
			this._setToken(this.token_word,this.caption);
			this._setToken(this.token_id,this.value);
		}
		
		_setToken(name, value) {
			var defaultTokenModel = this.mvc.Components.get('default');
			if (defaultTokenModel) {
				defaultTokenModel.set(name, value);
			}
			var submittedTokenModel = this.mvc.Components.get('submitted');
			if (submittedTokenModel) {
				submittedTokenModel.set(name, value);
			}
		}
	
	
	
	/* Create a list of custom colours
		*/
		addColorDefiniton(hexCode){
			if(this.colors[hexCode]) {
				return;
			}else{
				this.colors[hexCode] = "custom_color_" + this.id + "_";
			}
		}

		/* Get CSS for custom colors*/
		getCSSForCustomColors(){
			var css = "";
			var i;
			var counter = 0;
			var keys = Object.keys(this.colors);
			for(counter = 0; counter < keys.length; counter++){
				css += "." + this.colors[keys[counter]] + counter + "{color:" + keys[counter] + "; ";
				css += this.convertPicColorInCSS(keys[counter]) + ";} ";
				this.colors[keys[counter]] += counter; 
			}
			return css;
		}
		
		hexToRgb(hex) {
			  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
			  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
			  hex = hex.replace(shorthandRegex, (m, r, g, b) => {
				return r + r + g + g + b + b;
			  });

			  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			  return result
				? [
				  parseInt(result[1], 16),
				  parseInt(result[2], 16),
				  parseInt(result[3], 16),
				]
				: null;
			}

		convertPicColorInCSS(hexCode){
			var rgb = this.hexToRgb(hexCode);
			var color = new CSSColor(rgb[0], rgb[1], rgb[2]);
			var solver = new CSSColorSolver(color);
			var result = solver.solve();
			return result.filter;
		}
		
	
}


//--------------------------------- CSS Color Solver Classes--------------------------------------------------------------------------------
class CSSColor {
  constructor(r, g, b) {
    this.set(r, g, b);
  }
  
  toString() {
    return `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;
  }

  set(r, g, b) {
    this.r = this.clamp(r);
    this.g = this.clamp(g);
    this.b = this.clamp(b);
  }

  hueRotate(angle = 0) {
    angle = angle / 180 * Math.PI;
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);

    this.multiply([
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ]);
  }

  grayscale(value = 1) {
    this.multiply([
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ]);
  }

  sepia(value = 1) {
    this.multiply([
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ]);
  }

  saturate(value = 1) {
    this.multiply([
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ]);
  }

  multiply(matrix) {
    const newR = this.clamp(this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]);
    const newG = this.clamp(this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]);
    const newB = this.clamp(this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]);
    this.r = newR;
    this.g = newG;
    this.b = newB;
  }

  brightness(value = 1) {
    this.linear(value);
  }
  contrast(value = 1) {
    this.linear(value, -(0.5 * value) + 0.5);
  }

  linear(slope = 1, intercept = 0) {
    this.r = this.clamp(this.r * slope + intercept * 255);
    this.g = this.clamp(this.g * slope + intercept * 255);
    this.b = this.clamp(this.b * slope + intercept * 255);
  }

  invert(value = 1) {
    this.r = this.clamp((value + this.r / 255 * (1 - 2 * value)) * 255);
    this.g = this.clamp((value + this.g / 255 * (1 - 2 * value)) * 255);
    this.b = this.clamp((value + this.b / 255 * (1 - 2 * value)) * 255);
  }

  hsl() {
    // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
    const r = this.r / 255;
    const g = this.g / 255;
    const b = this.b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }

    return {
      h: h * 100,
      s: s * 100,
      l: l * 100,
    };
  }

  clamp(value) {
    if (value > 255) {
      value = 255;
    } else if (value < 0) {
      value = 0;
    }
    return value;
  }
}

class CSSColorSolver {
  constructor(target, baseColor) {
    this.target = target;
    this.targetHSL = target.hsl();
    this.reusedColor = new CSSColor(0, 0, 0);
  }

  solve() {
    const result = this.solveNarrow(this.solveWide());
    return {
      values: result.values,
      loss: result.loss,
      filter: this.css(result.values),
    };
  }

  solveWide() {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];

    let best = { loss: Infinity };
    for (let i = 0; best.loss > 25 && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = this.spsa(A, a, c, initial, 1000);
      if (result.loss < best.loss) {
        best = result;
      }
    }
    return best;
  }

  solveNarrow(wide) {
    const A = wide.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return this.spsa(A, a, c, wide.values, 500);
  }

  spsa(A, a, c, values, iters) {
    const alpha = 1;
    const gamma = 0.16666666666666666;

    let best = null;
    let bestLoss = Infinity;
    const deltas = new Array(6);
    const highArgs = new Array(6);
    const lowArgs = new Array(6);

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      for (let i = 0; i < 6; i++) {
        deltas[i] = Math.random() > 0.5 ? 1 : -1;
        highArgs[i] = values[i] + ck * deltas[i];
        lowArgs[i] = values[i] - ck * deltas[i];
      }

      const lossDiff = this.loss(highArgs) - this.loss(lowArgs);
      for (let i = 0; i < 6; i++) {
        const g = lossDiff / (2 * ck) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        values[i] = fix(values[i] - ak * g, i);
      }

      const loss = this.loss(values);
      if (loss < bestLoss) {
        best = values.slice(0);
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };

    function fix(value, idx) {
      let max = 100;
      if (idx === 2 /* saturate */) {
        max = 7500;
      } else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {
        max = 200;
      }

      if (idx === 3 /* hue-rotate */) {
        if (value > max) {
          value %= max;
        } else if (value < 0) {
          value = max + value % max;
        }
      } else if (value < 0) {
        value = 0;
      } else if (value > max) {
        value = max;
      }
      return value;
    }
  }

  loss(filters) {
    // Argument is array of percentages.
    const color = this.reusedColor;
    color.set(0, 0, 0);

    color.invert(filters[0] / 100);
    color.sepia(filters[1] / 100);
    color.saturate(filters[2] / 100);
    color.hueRotate(filters[3] * 3.6);
    color.brightness(filters[4] / 100);
    color.contrast(filters[5] / 100);

    const colorHSL = color.hsl();
    return (
      Math.abs(color.r - this.target.r) +
      Math.abs(color.g - this.target.g) +
      Math.abs(color.b - this.target.b) +
      Math.abs(colorHSL.h - this.targetHSL.h) +
      Math.abs(colorHSL.s - this.targetHSL.s) +
      Math.abs(colorHSL.l - this.targetHSL.l)
    );
  }

  css(filters) {
    function fmt(idx, multiplier = 1) {
      return Math.round(filters[idx] * multiplier);
    }
    return `filter: invert(${fmt(0)}%) sepia(${fmt(1)}%) saturate(${fmt(2)}%) hue-rotate(${fmt(3, 3.6)}deg) brightness(${fmt(4)}%) contrast(${fmt(5)}%);`;
  }
}



module.exports =  {departures_board,CSSColor};

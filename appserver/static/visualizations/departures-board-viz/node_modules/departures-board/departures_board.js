"use strict";

var departures_board = /*#__PURE__*/ (function () {
  function departures_board() {
    this.words = [];
    this.value = ""; // The value for token_id

    this.id = this.createUUID();
    this.caption = "";
    this.label = "";
    this.max_num_characters = 50; // Defined here - limit the num_chars of the viz
    //Defaults:

    this.num_characters = 5;
    this.auto_refresh = true;
    this.auto_refresh_period = 5;
    this.timing = 500;
    this.size = "XXL";
    this.dark_tiles = false;
    this.force_all_caps = true;
    this.token_word = "dbv_term";
    this.token_id = "dbv_id";
    this.is_fixed_length = false;
    this.align = "left";
    this.text_align = "left";
    this.mvc = "";
    this.interval_handler = "";
    this.colors = [];
    this.customColor;
  }

  var _proto = departures_board.prototype;

  _proto.setConfig = function setConfig(config, namespace, mvc) {
    // Get Config parameters:
    var vizUtils = require("api/SplunkVisualizationUtils");

    this.num_characters = parseInt(config[namespace + "num_characters"]) || 5;

    if (this.num_characters > this.max_num_characters) {
      this.num_characters = this.max_num_characters;
    }

    this.auto_refresh = vizUtils.normalizeBoolean(
      config[namespace + "auto_refresh"],
      true
    );
    this.auto_refresh_period =
      parseInt(config[namespace + "auto_refresh_period"]) || 5;
    this.timing = parseInt(config[namespace + "timing"]) || 500;
    this.size = vizUtils.escapeHtml(config[namespace + "size"]) || "XXL";
    this.theme = vizUtils.escapeHtml(config[namespace + "theme"]) || "light";
    this.force_all_caps = vizUtils.normalizeBoolean(
      config[namespace + "force_all_caps"],
      true
    );
    this.label = vizUtils.escapeHtml(config[namespace + "label"]) || "";
    this.customColor =
      vizUtils.escapeHtml(config[namespace + "customColor"]) || "#ffffff";
    this.token_word =
      vizUtils.escapeHtml(config[namespace + "token_term"]) || "dbv_term";
    this.token_id =
      vizUtils.escapeHtml(config[namespace + "token_id"]) || "dbv_id";
    this.caption = "";
    this.is_fixed_length = vizUtils.normalizeBoolean(
      config[namespace + "is_fixed_length"],
      false
    );
    this.align = vizUtils.escapeHtml(config[namespace + "align"]) || "left";
    this.text_align =
      vizUtils.escapeHtml(config[namespace + "text_align"]) || "left";

    if (
      this.theme != "light" &&
      this.theme != "dark" &&
      this.theme != "custom"
    ) {
      this.theme = "light";
    }

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.test(this.customColor);
    this.customColor = result ? this.customColor : "#000000";

    if (!this.is_fixed_length) {
      this.num_characters = 1;
    }

    this.timing = parseInt(this.timing, 10);

    if (this.timing < 1) {
      this.timing = 1;
    }

    this.mvc = mvc; // Clean caption

    var vizUtils = require("api/SplunkVisualizationUtils"); //Refresh period cannot be less than 1s

    var reValidateRefreshPeriod = new RegExp("\\d{1,3}(\\.\\d+)?");

    if (
      reValidateRefreshPeriod.test(this.auto_refresh_period) != true ||
      this.auto_refresh_period < 1
    ) {
      this.auto_refresh_period = 5;
    } //Timing mus be at least 100ms

    var reValidateAnimationPeriod = new RegExp("\\d{3,4}");

    if (
      reValidateAnimationPeriod.test(this.timing) != true ||
      this.timing < 100
    ) {
      this.timing = 500;
    }
  };

  _proto.setText = function setText(data) {
    var SplunkVisUtils = require("api/SplunkVisualizationUtils");

    var vizUtils = require("api/SplunkVisualizationUtils");

    this.caption = "";
    var i = 0;
    var str = "";
    var val = "";

    try {
      //------------------------------  Get data row field indexes ----------------------------------------------------------------------
      for (i = 0; i < data.rows.length; i++) {
        // Set the key value pair:
        str = this.force_all_caps
          ? data.rows[i][0].toUpperCase()
          : data.rows[i][0];
        val = data.rows[i].length > 1 ? data.rows[i][1] : "";
        this.words.push({
          word: str,
          value: val
        });

        if (!this.is_fixed_length && str.length > this.num_characters) {
          //Limit the length to this.max_num_characters
          if (str.length <= this.max_num_characters) {
            this.num_characters = str.length;
          } else {
            this.num_characters = this.max_num_characters;
          }
        }
      } // loop
    } catch (err) {
      console.log("Error setting data. " + err);
    }
  }; // Return the HTML for the visualization

  _proto.getHTML = function getHTML() {
    var cssTheme;
    var customCSS = "";

    switch (this.theme) {
      case "dark":
        cssTheme = "dark";
        break;

      case "custom":
        cssTheme = "dark";
        customCSS = this.convertPicColorInCSS(this.customColor);
        break;

      default:
        cssTheme = "light";
    }

    var cssAlign = "text-align: " + this.align + ";";

    if (this.align == "left") {
      cssAlign += "display: inline-block;";
    }

    var html =
      "<style>" +
      this.getCSSForCustomColors() +
      '</style><div class="dbv_container" style="' +
      cssAlign +
      customCSS +
      '"><div class="dvb_sub_container"><input class="header ' +
      cssTheme +
      " " +
      this.size +
      '" id="' +
      this.id +
      '" /><div class="dbv_label">' +
      this.label +
      "</div></div></div>";
    return html;
  }; // Get the next word. If we are centre aligning, pad with the right number of spaces.

  _proto.getNextWord = function getNextWord() {
    try {
      var vals = this.words.shift();
      this.words.push(vals);
      this.caption = vals["word"];
      this.value = vals["value"];

      if (this.text_align == "center") {
        var paddingCount = Math.floor(
          (this.num_characters - vals["word"].length) / 2
        );

        if (paddingCount > 0) {
          var padding = Array(paddingCount + 1).join(" ");
          vals["word"] = padding + vals["word"];
        }
      }

      return vals["word"];
    } catch (err) {
      console.log("Error getting current word" + err);
      return "error!";
    }
  }; // Get the OPTS for the visualization

  _proto.getOpts = function getOpts() {
    //Center align is just left with padding
    var align = this.text_align;

    if (align == "center") {
      align = "left";
    }

    return {
      chars_preset: "alphanum",
      align: align,
      width: this.num_characters,
      timing: this.timing,
      transform: true
    };
  }; // Create a unique ID for the CSS selector

  _proto.createUUID = function createUUID() {
    var s = [];
    var hexDigits = "0123456789abcdef";

    for (var i = 0; i < 10; i++) {
      s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }

    var uuid = s.join("");
    return "db_" + uuid;
  };

  _proto.start = function start() {
    window.jQuery("#" + this.id).flapper(this.getOpts());
    $("#" + this.id)
      .val(this.getNextWord())
      .change();
    this.setTokens();
    var thisObj = this;

    if (this.auto_refresh) {
      thisObj.interval_handler = window.setInterval(function () {
        //Apoptosis:
        if ($("#" + thisObj.id).length == 0) {
          window.clearInterval(thisObj.interval_handler);
        } else {
          if (thisObj.words.length == 1) {
            $("#" + thisObj.id)
              .val("")
              .change();
          }

          $("#" + thisObj.id)
            .val(thisObj.getNextWord())
            .change();
          thisObj.setTokens();
        }
      }, this.auto_refresh_period * 1000);
    }
  };

  _proto.setTokens = function setTokens() {
    this._setToken(this.token_word, this.caption);

    this._setToken(this.token_id, this.value);
  };

  _proto._setToken = function _setToken(name, value) {
    var defaultTokenModel = this.mvc.Components.get("default");

    if (defaultTokenModel) {
      defaultTokenModel.set(name, value);
    }

    var submittedTokenModel = this.mvc.Components.get("submitted");

    if (submittedTokenModel) {
      submittedTokenModel.set(name, value);
    }
  };
  /* Create a list of custom colours
   */

  _proto.addColorDefiniton = function addColorDefiniton(hexCode) {
    if (this.colors[hexCode]) {
      return;
    } else {
      this.colors[hexCode] = "custom_color_" + this.id + "_";
    }
  };
  /* Get CSS for custom colors*/

  _proto.getCSSForCustomColors = function getCSSForCustomColors() {
    var css = "";
    var i;
    var counter = 0;
    var keys = Object.keys(this.colors);

    for (counter = 0; counter < keys.length; counter++) {
      css +=
        "." +
        this.colors[keys[counter]] +
        counter +
        "{color:" +
        keys[counter] +
        "; ";
      css += this.convertPicColorInCSS(keys[counter]) + ";} ";
      this.colors[keys[counter]] += counter;
    }

    return css;
  };

  _proto.hexToRgb = function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ]
      : null;
  };

  _proto.convertPicColorInCSS = function convertPicColorInCSS(hexCode) {
    var rgb = this.hexToRgb(hexCode);
    var color = new CSSColor(rgb[0], rgb[1], rgb[2]);
    var solver = new CSSColorSolver(color);
    var result = solver.solve();
    return result.filter;
  };

  return departures_board;
})(); //--------------------------------- CSS Color Solver Classes--------------------------------------------------------------------------------

var CSSColor = /*#__PURE__*/ (function () {
  function CSSColor(r, g, b) {
    this.set(r, g, b);
  }

  var _proto2 = CSSColor.prototype;

  _proto2.toString = function toString() {
    return (
      "rgb(" +
      Math.round(this.r) +
      ", " +
      Math.round(this.g) +
      ", " +
      Math.round(this.b) +
      ")"
    );
  };

  _proto2.set = function set(r, g, b) {
    this.r = this.clamp(r);
    this.g = this.clamp(g);
    this.b = this.clamp(b);
  };

  _proto2.hueRotate = function hueRotate(angle) {
    if (angle === void 0) {
      angle = 0;
    }

    angle = (angle / 180) * Math.PI;
    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    this.multiply([
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.14,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072
    ]);
  };

  _proto2.grayscale = function grayscale(value) {
    if (value === void 0) {
      value = 1;
    }

    this.multiply([
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value)
    ]);
  };

  _proto2.sepia = function sepia(value) {
    if (value === void 0) {
      value = 1;
    }

    this.multiply([
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value)
    ]);
  };

  _proto2.saturate = function saturate(value) {
    if (value === void 0) {
      value = 1;
    }

    this.multiply([
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value
    ]);
  };

  _proto2.multiply = function multiply(matrix) {
    var newR = this.clamp(
      this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]
    );
    var newG = this.clamp(
      this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]
    );
    var newB = this.clamp(
      this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]
    );
    this.r = newR;
    this.g = newG;
    this.b = newB;
  };

  _proto2.brightness = function brightness(value) {
    if (value === void 0) {
      value = 1;
    }

    this.linear(value);
  };

  _proto2.contrast = function contrast(value) {
    if (value === void 0) {
      value = 1;
    }

    this.linear(value, -(0.5 * value) + 0.5);
  };

  _proto2.linear = function linear(slope, intercept) {
    if (slope === void 0) {
      slope = 1;
    }

    if (intercept === void 0) {
      intercept = 0;
    }

    this.r = this.clamp(this.r * slope + intercept * 255);
    this.g = this.clamp(this.g * slope + intercept * 255);
    this.b = this.clamp(this.b * slope + intercept * 255);
  };

  _proto2.invert = function invert(value) {
    if (value === void 0) {
      value = 1;
    }

    this.r = this.clamp((value + (this.r / 255) * (1 - 2 * value)) * 255);
    this.g = this.clamp((value + (this.g / 255) * (1 - 2 * value)) * 255);
    this.b = this.clamp((value + (this.b / 255) * (1 - 2 * value)) * 255);
  };

  _proto2.hsl = function hsl() {
    // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
    var r = this.r / 255;
    var g = this.g / 255;
    var b = this.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h,
      s,
      l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h * 100,
      s: s * 100,
      l: l * 100
    };
  };

  _proto2.clamp = function clamp(value) {
    if (value > 255) {
      value = 255;
    } else if (value < 0) {
      value = 0;
    }

    return value;
  };

  return CSSColor;
})();

var CSSColorSolver = /*#__PURE__*/ (function () {
  function CSSColorSolver(target, baseColor) {
    this.target = target;
    this.targetHSL = target.hsl();
    this.reusedColor = new CSSColor(0, 0, 0);
  }

  var _proto3 = CSSColorSolver.prototype;

  _proto3.solve = function solve() {
    var result = this.solveNarrow(this.solveWide());
    return {
      values: result.values,
      loss: result.loss,
      filter: this.css(result.values)
    };
  };

  _proto3.solveWide = function solveWide() {
    var A = 5;
    var c = 15;
    var a = [60, 180, 18000, 600, 1.2, 1.2];
    var best = {
      loss: Infinity
    };

    for (var i = 0; best.loss > 25 && i < 3; i++) {
      var initial = [50, 20, 3750, 50, 100, 100];
      var result = this.spsa(A, a, c, initial, 1000);

      if (result.loss < best.loss) {
        best = result;
      }
    }

    return best;
  };

  _proto3.solveNarrow = function solveNarrow(wide) {
    var A = wide.loss;
    var c = 2;
    var A1 = A + 1;
    var a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return this.spsa(A, a, c, wide.values, 500);
  };

  _proto3.spsa = function spsa(A, a, c, values, iters) {
    var alpha = 1;
    var gamma = 0.16666666666666666;
    var best = null;
    var bestLoss = Infinity;
    var deltas = new Array(6);
    var highArgs = new Array(6);
    var lowArgs = new Array(6);

    for (var k = 0; k < iters; k++) {
      var ck = c / Math.pow(k + 1, gamma);

      for (var i = 0; i < 6; i++) {
        deltas[i] = Math.random() > 0.5 ? 1 : -1;
        highArgs[i] = values[i] + ck * deltas[i];
        lowArgs[i] = values[i] - ck * deltas[i];
      }

      var lossDiff = this.loss(highArgs) - this.loss(lowArgs);

      for (var _i = 0; _i < 6; _i++) {
        var g = (lossDiff / (2 * ck)) * deltas[_i];
        var ak = a[_i] / Math.pow(A + k + 1, alpha);
        values[_i] = fix(values[_i] - ak * g, _i);
      }

      var loss = this.loss(values);

      if (loss < bestLoss) {
        best = values.slice(0);
        bestLoss = loss;
      }
    }

    return {
      values: best,
      loss: bestLoss
    };

    function fix(value, idx) {
      var max = 100;

      if (
        idx === 2
        /* saturate */
      ) {
        max = 7500;
      } else if (
        idx === 4 ||
        /* brightness */
        idx === 5
        /* contrast */
      ) {
        max = 200;
      }

      if (
        idx === 3
        /* hue-rotate */
      ) {
        if (value > max) {
          value %= max;
        } else if (value < 0) {
          value = max + (value % max);
        }
      } else if (value < 0) {
        value = 0;
      } else if (value > max) {
        value = max;
      }

      return value;
    }
  };

  _proto3.loss = function loss(filters) {
    // Argument is array of percentages.
    var color = this.reusedColor;
    color.set(0, 0, 0);
    color.invert(filters[0] / 100);
    color.sepia(filters[1] / 100);
    color.saturate(filters[2] / 100);
    color.hueRotate(filters[3] * 3.6);
    color.brightness(filters[4] / 100);
    color.contrast(filters[5] / 100);
    var colorHSL = color.hsl();
    return (
      Math.abs(color.r - this.target.r) +
      Math.abs(color.g - this.target.g) +
      Math.abs(color.b - this.target.b) +
      Math.abs(colorHSL.h - this.targetHSL.h) +
      Math.abs(colorHSL.s - this.targetHSL.s) +
      Math.abs(colorHSL.l - this.targetHSL.l)
    );
  };

  _proto3.css = function css(filters) {
    function fmt(idx, multiplier) {
      if (multiplier === void 0) {
        multiplier = 1;
      }

      return Math.round(filters[idx] * multiplier);
    }

    return (
      "filter: saturate(100%) invert(" +
      fmt(0) +
      "%) sepia(" +
      fmt(1) +
      "%) saturate(" +
      fmt(2) +
      "%) hue-rotate(" +
      fmt(3, 3.6) +
      "deg) brightness(" +
      fmt(4) +
      "%) contrast(" +
      fmt(5) +
      "%);"
    );
  };

  return CSSColorSolver;
})();

module.exports = {
  departures_board: departures_board,
  CSSColor: CSSColor
};
